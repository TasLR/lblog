---
title: buffer
published: 2024-07-16
description: ''
image: ''
tags: [freeRTOS,interaction]
category: RTOS
draft: false 
---
## buffer

> 默认情况下，单一写和单一读是安全的，若是多任务同时访问buffer，则需要将其放入临界区

### StreamBuffer

```
有一个触发机制，用于指定等待可用的数据长度 ，一旦触发则读取任务解除阻塞，即使读取任务的读缓冲区设置得小于流缓冲区的大小，仍可正常读
```

### messageBuffer

```
再发送方写数据时，系统会附加一个消息长度数据，读取任务buffer时，若读取缓冲区足够大，则调用一次API可以读取一条完整的消息，若缓冲区过小，则消息仍存于缓冲区，读取失败，同时数据可读前超时也会读取失败
```

### 差异对比

|      | stream                                 | message                                     |
| :--- | :------------------------------------- | :------------------------------------------ |
| 发送 | 再可完全写入前超时，仍会尽可能多地写入 | 在空前足够前超时，返回0                     |
| 接收 | 超时会读不全                           | 消息可用前超时、消息长度大于接收长度，返回0 |

### 流操作

- 缓冲区删除，资源回收，句柄不可用
- 缓冲区重置，内容被情况，但只可在无任务阻塞等待访问时使用

### 注意的问题

- 一般应用在音视频、网络通信等大数据交互场景下
- 消息队列的大小分配时，需要考虑额外的数据长度数据
- 消息队列由于其数据包附带了消息长度，故即使每次消息长度不一样也不影响消息的接收，当然了 ，接收的缓冲区需要根据情况设置足够大，因为一条消息只有读（读缓冲区足够大，一次读取一条完整的消息）和读失败（读缓冲区过小或无消息可读）的情况